{"ast":null,"code":"export function extractWowheadBisList(scrapedPage, tabName = 'Overall') {\n  const markup = extractWowheadMarkupPayload(scrapedPage);\n  const tabBlock = extractTabBlock(markup, tabName) ?? markup;\n  const gearTable = extractMainBisGearTable(tabBlock) ?? tabBlock;\n  const rowRegex = /\\[tr\\]([\\s\\S]*?)\\[\\/tr\\]/g;\n  const items = [];\n  let match;\n\n  while ((match = rowRegex.exec(gearTable)) !== null) {\n    const row = match[1] ?? '';\n    const cells = extractTdCells(row);\n\n    if (cells.length < 3) {\n      continue;\n    }\n\n    const slot = normalizeSlot(cleanWowheadCellText(cells[0]));\n\n    if (!slot || /^slot$/i.test(slot)) {\n      continue;\n    } // Some tables are 4 columns (slot, enchant, item, source), others 3 (slot, item, source).\n\n\n    const itemCell = cells.find(cell => /\\[item=\\d+/i.test(cell)) ?? '';\n    const sourceCell = cells[cells.length - 1] ?? '';\n    const itemId = extractItemId(itemCell);\n    const source = cleanWowheadCellText(sourceCell);\n\n    if (!slot || Number.isNaN(itemId) || itemId <= 0) {\n      continue;\n    }\n\n    items.push({\n      slot,\n      itemId,\n      source\n    });\n  }\n\n  return items;\n}\n\nfunction extractMainBisGearTable(tabBlock) {\n  // Try to anchor to the main \"Best in Slot Gear\" heading first, then take the first table.\n  const headingRegex = /\\[h3[^\\]]*\\][^\\[]*Best in Slot Gear[^\\[]*\\[\\/h3\\]/i;\n  const headingMatch = tabBlock.match(headingRegex);\n  const searchStart = headingMatch?.index ?? 0;\n  const slice = tabBlock.slice(searchStart);\n  const tableMatch = slice.match(/\\[table[^\\]]*\\][\\s\\S]*?\\[\\/table\\]/i);\n  return tableMatch ? tableMatch[0] : null;\n}\n\nfunction extractWowheadMarkupPayload(page) {\n  const marker = 'WH.markup.printHtml(\"';\n  const start = page.indexOf(marker);\n\n  if (start === -1) {\n    throw new Error('Could not locate WH.markup.printHtml payload.');\n  }\n\n  const contentStart = start + marker.length;\n  let i = contentStart;\n  let escaped = false;\n  let raw = '';\n\n  while (i < page.length) {\n    const ch = page[i];\n\n    if (!escaped && ch === '\"') {\n      // End of JS string literal.\n      break;\n    }\n\n    if (escaped) {\n      raw += '\\\\' + ch;\n      escaped = false;\n    } else if (ch === '\\\\') {\n      escaped = true;\n    } else {\n      raw += ch;\n    }\n\n    i++;\n  }\n\n  if (i >= page.length) {\n    throw new Error('Unterminated WH.markup.printHtml payload.');\n  }\n\n  return decodeJsEscapedString(raw);\n}\n\nfunction decodeJsEscapedString(value) {\n  return value.replace(/\\\\\\\\/g, '\\\\').replace(/\\\\\"/g, '\"').replace(/\\\\\\//g, '/').replace(/\\\\r\\\\n/g, '\\n').replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t');\n}\n\nfunction extractTabBlock(markup, tabName) {\n  const escapedTab = escapeRegex(tabName);\n  const tabRegex = new RegExp(`\\\\[tab name=\"${escapedTab}\"[^\\\\]]*\\\\][\\\\s\\\\S]*?\\\\[\\\\/tab\\\\]`, 'i');\n  const match = markup.match(tabRegex);\n  return match ? match[0] : null;\n}\n\nfunction normalizeSlot(slot) {\n  return slot.replace(/ring\\s*1/gi, 'Ring').replace(/ring\\s*2/gi, 'Ring').replace(/one-hand weapon/gi, 'One-Hand Weapon').replace(/two-hand weapon/gi, 'Two-Hand Weapon').replace(/\\s+/g, ' ').trim();\n}\n\nfunction extractItemId(itemCell) {\n  const match = itemCell.match(/\\[item=(\\d+)/i);\n\n  if (!match) {\n    return NaN;\n  }\n\n  return Number(match[1]);\n}\n\nfunction cleanWowheadCellText(value) {\n  return value.replace(/<[^>]*>/g, ' ').replace(/\\[[^\\]]+\\]/g, ' ').replace(/&nbsp;/gi, ' ').replace(/\\|/g, ' ').replace(/\\s+/g, ' ').trim();\n}\n\nfunction extractTdCells(row) {\n  const cells = [];\n  const tdRegex = /\\[td[^\\]]*\\]([\\s\\S]*?)\\[\\/td\\]/gi;\n  let tdMatch;\n\n  while ((tdMatch = tdRegex.exec(row)) !== null) {\n    cells.push(tdMatch[1] ?? '');\n  }\n\n  return cells;\n}\n\nfunction escapeRegex(input) {\n  return input.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}","map":null,"metadata":{},"sourceType":"module"}